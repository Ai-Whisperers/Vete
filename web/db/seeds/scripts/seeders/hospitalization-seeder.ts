/**
 * Hospitalization Seeder
 *
 * Seeds hospitalization data with auto-generated admission numbers.
 * Handles the critical requirement for NOT NULL admission_number.
 */

import type { SupabaseClient } from '@supabase/supabase-js'
import { BaseSeeder, SeederOptions, SeederResult } from './base-seeder'
import { createSeederResult } from '../utils/reporting'
import {
  HospitalizationSchema,
  Hospitalization,
  HospitalizationVitalsSchema,
  HospitalizationVitals,
  HospitalizationMedicationSchema,
  HospitalizationMedication,
  HospitalizationFeedingSchema,
  HospitalizationFeeding,
  generateAdmissionNumber,
} from '@/lib/test-utils/schemas'
import { upsertWithIdempotency } from '../utils/idempotency'
import { validateBatch } from '../utils/validation'

/**
 * Hospitalization Seeder
 *
 * Seeds hospitalization records with auto-generated admission numbers.
 */
export class HospitalizationSeeder extends BaseSeeder<Hospitalization> {
  private admissionCounter: number = 0

  getTableName(): string {
    return 'hospitalizations'
  }

  getSchema() {
    return HospitalizationSchema
  }

  async loadData(): Promise<unknown[]> {
    // Try to load from JSON first
    try {
      const json = await this.loadJsonFile<{
        hospitalizations?: Array<Record<string, unknown>>
      }>(`db/seeds/data/02-clinic/${this.getTenantId()}/hospitalizations.json`)
      return json.hospitalizations || []
    } catch {
      // No JSON file - return empty (will be generated by factory in demo mode)
      return []
    }
  }

  /**
   * Pre-process to add admission_number if missing and fix field mappings
   */
  protected async preProcess(data: unknown[]): Promise<unknown[]> {
    if (!data || !Array.isArray(data) || data.length === 0) return []

    // Get current max admission number from database
    const { data: existing } = await this.client
      .from('hospitalizations')
      .select('admission_number')
      .eq('tenant_id', this.getTenantId())
      .order('created_at', { ascending: false })
      .limit(1)

    if (existing && existing.length > 0) {
      // Extract number from admission_number like "ADM-2024-0001"
      const match = existing[0].admission_number?.match(/ADM-\d+-(\d+)/)
      if (match) {
        this.admissionCounter = parseInt(match[1], 10)
      }
    }

    // Look up kennels by code to resolve kennel_id
    const { data: kennels } = await this.client
      .from('kennels')
      .select('id, code')
      .eq('tenant_id', this.getTenantId())

    const kennelCodeToId = new Map<string, string>()
    if (kennels) {
      for (const kennel of kennels) {
        kennelCodeToId.set(kennel.code, kennel.id)
        // Also map by numeric index (1 -> first kennel, etc.)
        kennelCodeToId.set(String(kennels.indexOf(kennel) + 1), kennel.id)
      }
    }

    // Valid DB columns only
    const dbColumns = [
      'tenant_id',
      'pet_id',
      'kennel_id',
      'admission_number',
      'admitted_at',
      'expected_discharge',
      'actual_discharge',
      'reason',
      'diagnosis',
      'notes',
      'discharge_instructions',
      'status',
      'acuity_level',
      'primary_vet_id',
      'admitted_by',
      'discharged_by',
    ]

    return data.map((item) => {
      const record = item as Record<string, unknown>
      const cleaned: Record<string, unknown> = {}

      // Copy only DB columns
      for (const col of dbColumns) {
        if (col in record) {
          cleaned[col] = record[col]
        }
      }

      // Add tenant_id if missing
      if (!cleaned.tenant_id) {
        cleaned.tenant_id = this.getTenantId()
      }

      // Generate admission_number if missing
      if (!cleaned.admission_number) {
        this.admissionCounter++
        cleaned.admission_number = generateAdmissionNumber(this.admissionCounter)
      }

      // Map reason_for_admission -> reason
      if (!cleaned.reason && record.reason_for_admission) {
        cleaned.reason = record.reason_for_admission
      }

      // Map vet_id -> primary_vet_id
      if (!cleaned.primary_vet_id && record.vet_id) {
        cleaned.primary_vet_id = record.vet_id
      }

      // Resolve kennel_id from code
      if (record.kennel_id && typeof record.kennel_id === 'string') {
        const resolved = kennelCodeToId.get(record.kennel_id)
        if (resolved) {
          cleaned.kennel_id = resolved
        } else {
          // If not found, set to null (optional field)
          cleaned.kennel_id = null
        }
      }

      // Fix common column name mistakes
      if (record.discharged_at && !cleaned.actual_discharge) {
        cleaned.actual_discharge = record.discharged_at
      }

      // Map discharge_diagnosis to diagnosis if not set
      if (!cleaned.diagnosis && record.discharge_diagnosis) {
        cleaned.diagnosis = record.discharge_diagnosis
      }

      // Fix acuity_level if using invalid value
      if (cleaned.acuity_level === 'stable') {
        cleaned.acuity_level = 'normal'
      }

      return cleaned
    })
  }

  /**
   * After creating hospitalizations, seed related records
   */
  protected async postProcess(created: Hospitalization[]): Promise<void> {
    // For each hospitalization, create sample vitals
    for (const hosp of created) {
      await this.seedVitals(hosp)
    }
  }

  private async seedVitals(hospitalization: Hospitalization): Promise<void> {
    // Create 2-3 vitals records per hospitalization
    const vitalsCount = Math.floor(Math.random() * 2) + 2
    const vitalsRecords: unknown[] = []

    const now = new Date()
    for (let i = 0; i < vitalsCount; i++) {
      const recordedAt = new Date(now)
      recordedAt.setHours(recordedAt.getHours() - (vitalsCount - i) * 4)

      vitalsRecords.push({
        hospitalization_id: hospitalization.id,
        temperature: 38 + Math.random() * 2, // 38-40°C
        heart_rate: 80 + Math.floor(Math.random() * 40), // 80-120 bpm
        respiratory_rate: 15 + Math.floor(Math.random() * 15), // 15-30
        pain_score: Math.floor(Math.random() * 4), // 0-3
        mentation: 'quiet',
        recorded_at: recordedAt.toISOString(),
      })
    }

    const validation = validateBatch(HospitalizationVitalsSchema, vitalsRecords)

    if (validation.totalValid > 0) {
      await this.client.from('hospitalization_vitals').insert(validation.valid)
    }
  }
}

/**
 * Generate demo hospitalizations using factory pattern
 */
export class HospitalizationDemoSeeder extends BaseSeeder<Hospitalization> {
  private petIds: string[] = []
  private kennelIds: string[] = []
  private vetId: string | null = null

  getTableName(): string {
    return 'hospitalizations'
  }

  getSchema() {
    return HospitalizationSchema
  }

  /**
   * Set dependencies before seeding
   */
  setDependencies(petIds: string[], kennelIds: string[], vetId: string): void {
    this.petIds = petIds
    this.kennelIds = kennelIds
    this.vetId = vetId
  }

  async loadData(): Promise<unknown[]> {
    if (this.petIds.length === 0 || this.kennelIds.length === 0) {
      this.log('No pets or kennels available for hospitalization demo')
      return []
    }

    const hospitalizations: unknown[] = []
    const count = Math.min(3, this.petIds.length)

    for (let i = 0; i < count; i++) {
      const admitDate = new Date()
      admitDate.setDate(admitDate.getDate() - i * 3) // Stagger admissions

      const isDischarge = i > 0 // First one is current, others discharged

      hospitalizations.push({
        tenant_id: this.getTenantId(),
        pet_id: this.petIds[i],
        kennel_id: this.kennelIds[i % this.kennelIds.length],
        admitted_at: admitDate.toISOString(),
        admitted_by: this.vetId,
        primary_vet_id: this.vetId,
        reason: ['Cirugía programada', 'Observación post-operatoria', 'Tratamiento IV'][i % 3],
        diagnosis: ['Piometra', 'Fractura tibial', 'Gastroenteritis'][i % 3],
        status: isDischarge ? 'discharged' : 'admitted',
        acuity_level: ['normal', 'high', 'critical'][i % 3],
        notes: `Paciente ingresado para ${['cirugía', 'observación', 'tratamiento'][i % 3]}`,
        actual_discharge: isDischarge ? new Date().toISOString() : null,
        discharged_by: isDischarge ? this.vetId : null,
      })
    }

    return hospitalizations
  }

  protected async preProcess(data: unknown[]): Promise<unknown[]> {
    if (!data || !Array.isArray(data) || data.length === 0) return []
    // Get current admission counter
    const { data: existing } = await this.client
      .from('hospitalizations')
      .select('admission_number')
      .eq('tenant_id', this.getTenantId())
      .order('created_at', { ascending: false })
      .limit(1)

    let counter = 0
    if (existing && existing.length > 0) {
      const match = existing[0].admission_number?.match(/ADM-\d+-(\d+)/)
      if (match) {
        counter = parseInt(match[1], 10)
      }
    }

    return data.map((item) => {
      const record = { ...(item as Record<string, unknown>) }
      counter++
      record.admission_number = generateAdmissionNumber(counter)
      return record
    })
  }
}
